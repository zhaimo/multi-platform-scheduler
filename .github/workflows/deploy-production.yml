name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    name: Deploy to Production Environment
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://your-domain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name || inputs.version }}
      
      - name: Set version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            echo "VERSION=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${{ inputs.version }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push images
        run: |
          VERSION=${{ steps.version.outputs.VERSION }}
          
          # Backend
          docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:$VERSION \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest \
            -f ./multi-platform-scheduler/backend/Dockerfile.prod \
            ./multi-platform-scheduler/backend
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:$VERSION
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest
          
          # Worker
          docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-worker:$VERSION \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest \
            -f ./multi-platform-scheduler/backend/Dockerfile.worker \
            ./multi-platform-scheduler/backend
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-worker:$VERSION
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest
          
          # Frontend
          docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:$VERSION \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest \
            -f ./multi-platform-scheduler/frontend/Dockerfile.prod \
            ./multi-platform-scheduler/frontend
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:$VERSION
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest
      
      - name: Create backup
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_USER: ${{ secrets.PROD_USER }}
        run: |
          ssh -i ~/.ssh/prod_key $PROD_USER@$PROD_HOST << 'EOF'
            cd /opt/video-scheduler
            mkdir -p backups
            docker-compose -f docker-compose.prod.yml exec -T postgres \
              pg_dump -U postgres video_scheduler > backups/pre_deploy_$(date +%Y%m%d_%H%M%S).sql
          EOF
      
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_SSH_KEY }}" > ~/.ssh/prod_key
          chmod 600 ~/.ssh/prod_key
          ssh-keyscan -H ${{ secrets.PROD_HOST }} >> ~/.ssh/known_hosts
      
      - name: Deploy to production server
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_USER: ${{ secrets.PROD_USER }}
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          ssh -i ~/.ssh/prod_key $PROD_USER@$PROD_HOST << EOF
            cd /opt/video-scheduler
            
            # Pull latest images
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:$VERSION
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-worker:$VERSION
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:$VERSION
            
            # Update docker-compose to use new images
            export BACKEND_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:$VERSION
            export WORKER_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-worker:$VERSION
            export FRONTEND_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:$VERSION
            
            # Run database migrations
            docker-compose -f docker-compose.prod.yml exec -T backend alembic upgrade head
            
            # Restart services with zero downtime
            docker-compose -f docker-compose.prod.yml up -d --no-deps backend
            sleep 10
            docker-compose -f docker-compose.prod.yml up -d --no-deps celery-worker
            sleep 5
            docker-compose -f docker-compose.prod.yml up -d --no-deps frontend
            
            # Clean up old images
            docker image prune -f
          EOF
      
      - name: Health check
        run: |
          sleep 30
          for i in {1..5}; do
            if curl -f https://your-domain.com/health; then
              echo "Health check passed"
              exit 0
            fi
            echo "Health check attempt $i failed, retrying..."
            sleep 10
          done
          echo "Health check failed after 5 attempts"
          exit 1
      
      - name: Rollback on failure
        if: failure()
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_USER: ${{ secrets.PROD_USER }}
        run: |
          ssh -i ~/.ssh/prod_key $PROD_USER@$PROD_HOST << 'EOF'
            cd /opt/video-scheduler
            echo "Deployment failed, rolling back..."
            docker-compose -f docker-compose.prod.yml down
            docker-compose -f docker-compose.prod.yml up -d
          EOF
      
      - name: Notify deployment success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: 'Production deployment successful: ${{ steps.version.outputs.VERSION }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
      
      - name: Notify deployment failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: 'Production deployment failed: ${{ steps.version.outputs.VERSION }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
